import sys
from _typeshed import SupportsTrunc
from collections.abc import Iterable
from decimal import Decimal as _Decimal
from random import Random
from typing import (
    Any, List, Literal, SupportsComplex, SupportsFloat, Tuple, Union,
    overload,
)

from typing_extensions import SupportsIndex, TypeAlias

from structures import Avl


if sys.version_info >= (3, 8):
    _SupportsFloatOrIndex: TypeAlias = SupportsFloat | SupportsIndex
else:
    _SupportsFloatOrIndex: TypeAlias = SupportsFloat

e: float
pi: float
inf: float
nan: float
tau: float

def acos(__x: _SupportsFloatOrIndex) -> float: ...
def acosh(__x: _SupportsFloatOrIndex) -> float: ...
def asin(__x: _SupportsFloatOrIndex) -> float: ...
def asinh(__x: _SupportsFloatOrIndex) -> float: ...
def atan(__x: _SupportsFloatOrIndex) -> float: ...
def atan2(__y: _SupportsFloatOrIndex, __x: _SupportsFloatOrIndex) -> float: ...
def atanh(__x: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 11):
    def cbrt(__x: _SupportsFloatOrIndex) -> float: ...

def ceil(__x: _SupportsFloatOrIndex) -> int: ...

if sys.version_info >= (3, 8):
    def comb(__n: SupportsIndex, __k: SupportsIndex) -> int: ...

def copysign(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
def cos(__x: _SupportsFloatOrIndex) -> float: ...
def cosh(__x: _SupportsFloatOrIndex) -> float: ...
def degrees(__x: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 8):
    def dist(
        __p: Iterable[_SupportsFloatOrIndex],
        __q: Iterable[_SupportsFloatOrIndex],
    ) -> float: ...

def erf(__x: _SupportsFloatOrIndex) -> float: ...
def erfc(__x: _SupportsFloatOrIndex) -> float: ...
def exp(__x: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 11):
    def exp2(__x: _SupportsFloatOrIndex) -> float: ...

def expm1(__x: _SupportsFloatOrIndex) -> float: ...
def fabs(__x: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 8):
    def factorial(__x: SupportsIndex) -> int: ...

else:
    def factorial(__x: int) -> int: ...

def floor(__x: _SupportsFloatOrIndex) -> int: ...
def fmod(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
def frexp(__x: _SupportsFloatOrIndex) -> tuple[float, int]: ...
def fsum(__seq: Iterable[_SupportsFloatOrIndex]) -> float: ...
def gamma(__x: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 9):
    def gcd(*integers: SupportsIndex) -> int: ...

else:
    def gcd(__x: SupportsIndex, __y: SupportsIndex) -> int: ...

if sys.version_info >= (3, 8):
    def hypot(*coordinates: _SupportsFloatOrIndex) -> float: ...

else:
    def hypot(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...

def isclose(
    a: _SupportsFloatOrIndex,
    b: _SupportsFloatOrIndex,
    *,
    rel_tol: _SupportsFloatOrIndex = ...,
    abs_tol: _SupportsFloatOrIndex = ...,
) -> bool: ...
def isinf(__x: _SupportsFloatOrIndex) -> bool: ...
def isfinite(__x: _SupportsFloatOrIndex) -> bool: ...
def isnan(__x: _SupportsFloatOrIndex) -> bool: ...

if sys.version_info >= (3, 8):
    def isqrt(__n: SupportsIndex) -> int: ...

if sys.version_info >= (3, 9):
    def lcm(*integers: SupportsIndex) -> int: ...

def ldexp(__x: _SupportsFloatOrIndex, __i: int) -> float: ...
def lgamma(__x: _SupportsFloatOrIndex) -> float: ...
def log(x: _SupportsFloatOrIndex, base: _SupportsFloatOrIndex = ...) -> float: ...
def log10(__x: _SupportsFloatOrIndex) -> float: ...
def log1p(__x: _SupportsFloatOrIndex) -> float: ...
def log2(__x: _SupportsFloatOrIndex) -> float: ...
def modf(__x: _SupportsFloatOrIndex) -> tuple[float, float]: ...

if sys.version_info >= (3, 9):
    def nextafter(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 8):
    def perm(__n: SupportsIndex, __k: SupportsIndex | None = ...) -> int: ...

def pow(x: _SupportsFloatOrIndex, _exp: _SupportsFloatOrIndex) -> float: ...

if sys.version_info >= (3, 8):
    @overload
    def prod(
        __iterable: Iterable[SupportsIndex],
        *,
        start: SupportsIndex = ...,
    ) -> int: ...  # type: ignore[misc]
    @overload
    def prod(
        __iterable: Iterable[_SupportsFloatOrIndex],
        *,
        start: _SupportsFloatOrIndex = ...,
    ) -> float: ...

def radians(__x: _SupportsFloatOrIndex) -> float: ...
def remainder(__x: _SupportsFloatOrIndex, __y: _SupportsFloatOrIndex) -> float: ...
def sin(__x: _SupportsFloatOrIndex) -> float: ...
def sinh(__x: _SupportsFloatOrIndex) -> float: ...
def sqrt(__x: _SupportsFloatOrIndex) -> float: ...
def tan(__x: _SupportsFloatOrIndex) -> float: ...
def tanh(__x: _SupportsFloatOrIndex) -> float: ...
def trunc(__x: SupportsTrunc) -> int: ...

if sys.version_info >= (3, 9):
    def ulp(__x: _SupportsFloatOrIndex) -> float: ...


def isOddNumber(x: int) -> bool:...
def isEvenNumber(x: int) -> bool:...

isOdd = odd = isOddNumber
isEven = even = isEvenNumber

prime: Avl
composite: Avl

def isPrime(x: int) -> bool:...
def BOS_min(a: (List | Tuple)[Any], x: Any) -> _SupportsFloatOrIndex | -1:...
def BOS_max(a: (List | Tuple)[Any], x: Any) -> _SupportsFloatOrIndex | -1:...
def isComposite(x: int) -> bool:...
def update_prime(x: int) -> List[bool]:...
def isint(x: _SupportsFloatOrIndex) -> bool:...
def toint(x: _SupportsFloatOrIndex) -> _SupportsFloatOrIndex:...
def tointfloat(x: _SupportsFloatOrIndex, accuracy: int) -> _SupportsFloatOrIndex:...
@overload
def numbers(
    start: SupportsIndex,
    number: SupportsIndex,
    step: SupportsIndex = 1,
) -> range:...
@overload
def numbers(number: SupportsIndex) -> range:...


DEGREES: str
RADIANS: str
_Type = Union[DEGREES, RADIANS]
Nmor : Tuple[str]
_nmor: Tuple[str]
Sbq  : Tuple[str]
_sbq : Tuple[str]
Sbqb : Tuple[str]
Sbqz : Tuple[str]
Ns   : Tuple[str]
Nsb  : Tuple[str]

def pronounce(
    x: SupportsIndex,
    s: Tuple[str] = _sbq,
    n: Tuple[str] = Ns,
    m: Tuple[str] = _nmor,
) -> str:...

def number(
    x: str,
    s: Tuple[str] = _sbq,
    n: Tuple[str] = Ns,
    m: Tuple[str] = _nmor,
) -> int:...

class Angle:
    degrees: int
    radians: int
    def __init__(self, types: _Type, number: _SupportsFloatOrIndex) -> None:...
    def __delattr__(self, item: str) -> None:... # raised
    def __float__(self) -> float:...
    def __int__(self) -> int:...
    def __str__(self) -> str:...
    def sin(self) -> float:...
    def cos(self) -> float:...
    def tan(self) -> float:...

_AnyNum = _SupportsFloatOrIndex | SupportsComplex
_complex = complex
epowi: complex

def epow(_exp: _AnyNum, powi: bool=False) -> _AnyNum:...
def tocomplexint(x: SupportsComplex) -> complex:...
def tocomplexintfloat(x: SupportsComplex, accuracy: SupportsIndex) -> complex:...

_CIP = str | complex | _SupportsFloatOrIndex
_RYR = complex | str

class Complex:
    _CIP |= Complex
    _RYR |= Complex
    _AnyNum |= Complex
    complex: _complex
    _complex |= Complex
    angle: Angle
    length: _SupportsFloatOrIndex
    imag: _SupportsFloatOrIndex
    real: _SupportsFloatOrIndex
    def epow(self: _complex) -> Complex:...
    def epowi(self: _complex) -> Complex:...
    def pow(self, _exp: _AnyNum) -> Complex:...
    __pow__ = pow
    def copy(self) -> Complex:...
    __copy__ = copy
    
    @overload
    def __init__(self, __obj: _CIP | List[Angle, int]) -> None:...
    @overload
    def __init__(self, angle: Angle, length: _SupportsFloatOrIndex) -> None:...
    @overload
    def __init__(
            self,
            types: _Type,
            number: _SupportsFloatOrIndex,
            length: _SupportsFloatOrIndex,
    ) -> None:...
    
    def __new__(cls, *args: Any, **kwargs: Any) -> Complex:...
    def __abs__(self) -> float:...
    def __complex__(self) -> _complex:...
    def __add__(self, other: _CIP) -> Complex:...
    def __sub__(self, other: _CIP) -> Complex:...
    def __mul__(self, other: _CIP) -> Complex:...
    def __divmod__(self, other: _CIP) -> Complex:...
    def __radd__(self, other: _CIP) -> _RYR:...
    def __rsub__(self, other: _CIP) -> _RYR: ...
    def __rmul__(self, other: _CIP) -> _RYR: ...
    def __rdivmod__(self, other: _CIP) -> _RYR: ...


class Decimal(_Decimal):
    def __init__(self, number: str | int | float | _Decimal) -> None:...


TWO_WAY: str
HEAD_TO_TAIL: str

def getpan(x: _SupportsFloatOrIndex) -> int:...
_ANC = _AnyNum
def ln(x: _ANC) -> complex | float:...
def log(x: _ANC, base: _ANC=2) -> complex | float:...
def log2(x: _ANC) -> complex | float:...
def lg(x: _ANC) -> complex | float:...
def lim(x: int) -> int:...

_Seed = _SupportsFloatOrIndex | (Tuple | List)[_SupportsFloatOrIndex, _SupportsFloatOrIndex] | (Tuple | List)[Random, _SupportsFloatOrIndex, _SupportsFloatOrIndex]
class Number:
    seed: _Seed
    type: Union[TWO_WAY, HEAD_TO_TAIL]
    l: _SupportsFloatOrIndex
    r: _SupportsFloatOrIndex
    number: float
    direction: Literal[1, -1]
    fps: _SupportsFloatOrIndex
    started: bool
    suspended: bool
    def __init__(
        self,
        seed: _Seed,
        types: Literal["two-way", "head to tail"],
        l: _SupportsFloatOrIndex,
        r: _SupportsFloatOrIndex,
        number: _SupportsFloatOrIndex,
        fps: _SupportsFloatOrIndex,
    ) -> None:...
    def get(self) -> float:...
    def __get__(self, instance: Any, owner: type) -> float:...
    def __float__(self) -> float:...
    def __int__(self) -> int:...
    def update(self) -> None:...
    def getseed(self) -> float:...
    def start(self) -> None:...
    def suspend(self) -> None:...
    def proceed(self) -> None:...
    def stop(self) -> None:...


import quaternion as _q
class Quaternion(_q.quaternion):
    pass
